# Порівняння алгоритмів сортування

У цьому дослідженні ми порівняли три алгоритми сортування: сортування злиттям, сортування вставками та Timsort.

## Сортування злиттям (Merge Sort)

- Час виконання: O(n log n)
- Стабільність: гарантована
- Опис: базується на розділенні масиву на менші частини, сортуванні їх окремо, а потім об'єднанні відсортованих підмасивів
- Ефективний для великих масивів

## Сортування вставками (Insertion Sort)

- Час виконання: O(n^2)
- Стабільність: гарантована
- Опис: перебирає елементи масиву один за одним і вставляє їх на відповідні позиції в відсортовану частину масиву
- Ефективний для невеликих масивів або вже відсортованих даних

## Timsort

- Час виконання: O(n log n).
- Стабільність: гарантована.
- Гібридний алгоритм, поєднує сортування злиттям і сортування вставками.
- Використовується в Python (наприклад, в sorted()), оскільки добре справляється з різними типами даних та різними розмірами масивів.


# Результати порівняльного аналізу алгоритмів за часом виконання шляхом їх тестування на різних наборах даних:

### Mасив випадкових цілих чисел розміром n = 10**3:

- Merge Sort time: 0.003265 seconds
- Insertion Sort time: 0.029810 seconds
- Timsort time_sorted: 0.000130 seconds

### Великий масив випадкових цілих чисел розміром n = 10**4

- Merge Sort time: 0.039242 seconds
- Insertion Sort time: 3.649547 seconds
- Timsort time_sorted: 0.001428 seconds

## Висновки:

Згідно з проведеними дослідами, коли ми маємо великий масив даних, Timsort є найефективнішим варіантом. Він поєднує переваги обох підходів (сортування злиттям та сортування вставками) і добре працює на різних наборах даних.

Сортування злиттям також демонструє свою ефективним, але повільніше за часом виконання.

Сортування вставками продемострувало найменшу швидкість, що відповідає його часовій складності. Його варто використовувати для невеликих масивів та в специфічних випадках.
